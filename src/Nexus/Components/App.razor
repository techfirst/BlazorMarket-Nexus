<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <base href="/" />
    <!-- Google Fonts - Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        // Apply dark theme immediately if saved in localStorage - prevents flash
        (function() {
            try {
                if (localStorage.getItem('theme') === 'dark') {
                    document.documentElement.classList.add('dark');
                }
            } catch (e) {
                // Ignore localStorage errors
            }
        })();
    </script>
    <style>
        :root {
            --bg-primary: #ffffff;
            --bg-secondary: #FAFBFC;
            --bg-tertiary: #F8FAFC;
            --bg-card: #ffffff;
            --text-primary: #0F172A;
            --text-secondary: #6B7280;
            --text-tertiary: #9CA3AF;
            --border-color: #E5E7EB;
            --border-light: #F3F4F6;
            --nexus-blue: #659BFF;
            --nexus-blue-dark: #4686FE;
            --nexus-blue-light: #E6F1FF;
        }
        
        .dark {
            --bg-primary: #0F172A;
            --bg-secondary: #1E293B;
            --bg-tertiary: #334155;
            --bg-card: #1E293B;
            --text-primary: #F1F5F9;
            --text-secondary: #CBD5E1;
            --text-tertiary: #94A3B8;
            --border-color: #334155;
            --border-light: #475569;
            --nexus-blue: #659BFF;
            --nexus-blue-dark: #4686FE;
            --nexus-blue-light: #1E3A5F;
        }
    </style>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        'nexus-blue': 'var(--nexus-blue)',
                        'nexus-blue-dark': 'var(--nexus-blue-dark)',
                        'nexus-blue-light': 'var(--nexus-blue-light)',
                        'nexus-gray': 'var(--bg-secondary)',
                        'nexus-dark': 'var(--text-primary)',
                        'nexus-light-gray': 'var(--bg-tertiary)',
                    },
                    fontFamily: {
                        'sans': ['Inter', '-apple-system', 'BlinkMacSystemFont', 'Segoe UI', 'Roboto', 'system-ui', 'sans-serif'],
                    },
                    fontWeight: {
                        'light': '300',
                        'normal': '400',
                        'medium': '500',
                        'semibold': '600', 
                        'bold': '700',
                    }
                }
            }
        }
    </script>
    <link rel="stylesheet" href="app.css" />
    <link rel="stylesheet" href="Nexus.styles.css" />
    <link rel="icon" type="image/png" href="favicon.png" />
    <HeadOutlet />
</head>

<body>
    <Routes />
    <script src="_framework/blazor.web.js"></script>
    <script>
        // Blazor anchor navigation system
        let isNavigatingToHash = false;
        let retryCount = 0;
        const maxRetries = 10;
        
        // Handle initial hash scroll after page load
        function handleInitialHashScroll() {
            if (window.location.hash && window.location.pathname === '/') {
                const sectionId = window.location.hash.substring(1);
                console.log('Initial hash scroll to:', sectionId);
                setTimeout(() => scrollToSection(sectionId), 200);
            }
        }
        
        // Smooth scroll to section function with retry logic
        function scrollToSection(sectionId) {
            const targetSection = document.getElementById(sectionId);
            
            if (targetSection) {
                const headerOffset = 80;
                const elementPosition = targetSection.getBoundingClientRect().top;
                const offsetPosition = elementPosition + window.pageYOffset - headerOffset;
                
                window.scrollTo({
                    top: offsetPosition,
                    behavior: 'smooth'
                });
                
                console.log('Successfully scrolled to section:', sectionId);
                retryCount = 0; // Reset retry count on success
            } else {
                retryCount++;
                console.log('Section not found, retry', retryCount, '/', maxRetries, '- looking for:', sectionId);
                
                // Element not found yet, try again with exponential backoff
                if (retryCount < maxRetries) {
                    const delay = Math.min(200 * retryCount, 2000); // Cap at 2 seconds
                    setTimeout(() => scrollToSection(sectionId), delay);
                } else {
                    console.warn('Failed to find section after', maxRetries, 'retries:', sectionId);
                    retryCount = 0; // Reset for next attempt
                }
            }
        }
        
        // Enhanced hash change handler
        window.addEventListener('hashchange', function(event) {
            const sectionId = window.location.hash.substring(1);
            console.log('Hash changed to:', sectionId, 'on path:', window.location.pathname);
            
            if (sectionId) {
                if (window.location.pathname === '/') {
                    // Already on home page, scroll immediately
                    scrollToSection(sectionId);
                } else {
                    // Not on home page, navigation will occur
                    console.log('Hash navigation will trigger page change');
                    isNavigatingToHash = true;
                }
            }
        });
        
        // Listen for Blazor navigation events
        window.addEventListener('popstate', function(event) {
            console.log('Popstate event - checking for hash navigation');
            setTimeout(handleInitialHashScroll, 100);
        });
        
        // Blazor-specific: Handle after Blazor renders
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded, checking for initial hash');
            handleInitialHashScroll();
        });
        
        // Additional check after potential Blazor re-renders
        function checkPendingHashNavigation() {
            if (isNavigatingToHash && window.location.hash && window.location.pathname === '/') {
                console.log('Handling pending hash navigation');
                isNavigatingToHash = false;
                const sectionId = window.location.hash.substring(1);
                setTimeout(() => scrollToSection(sectionId), 300);
            }
        }
        
        // Check for pending navigation periodically
        setInterval(checkPendingHashNavigation, 500);
        
        // Theme management for coordination with C# ThemeService
        window.themeHelper = {
            // Apply theme from localStorage on initial load only
            applyInitialTheme: function() {
                try {
                    const savedTheme = localStorage.getItem('theme');
                    if (savedTheme === 'dark') {
                        document.documentElement.classList.add('dark');
                    } else {
                        document.documentElement.classList.remove('dark');
                    }
                    console.log('Initial theme applied:', savedTheme || 'light');
                    console.log('DOM classList after initial apply:', document.documentElement.className);
                } catch (e) {
                    console.error('Could not apply initial theme:', e);
                }
            },
            
            // Called by C# ThemeService to apply theme changes
            setTheme: function(isDark) {
                try {
                    console.log('setTheme called with isDark:', isDark);
                    console.log('DOM classList before:', document.documentElement.className);
                    
                    // Force immediate theme application
                    document.documentElement.classList.remove('dark');
                    if (isDark) {
                        document.documentElement.classList.add('dark');
                    }
                    
                    // Also save to localStorage immediately
                    localStorage.setItem('theme', isDark ? 'dark' : 'light');
                    
                    console.log('DOM classList after:', document.documentElement.className);
                    console.log('Dark class present:', document.documentElement.classList.contains('dark'));
                    console.log('Theme set by C# completed:', isDark ? 'dark' : 'light');
                } catch (e) {
                    console.error('Could not set theme:', e);
                    throw e; // Re-throw so C# can catch it
                }
            },
            
            // Debug function to check current state
            getThemeState: function() {
                return {
                    classList: document.documentElement.className,
                    hasDark: document.documentElement.classList.contains('dark'),
                    localStorage: localStorage.getItem('theme')
                };
            }
        };
        
        // Apply initial theme immediately - before any rendering
        window.themeHelper.applyInitialTheme();
        
        // Apply theme as early as possible to prevent flash
        (function() {
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme === 'dark') {
                document.documentElement.classList.add('dark');
            }
        })();
        
        // Apply initial theme on page load events
        document.addEventListener('DOMContentLoaded', window.themeHelper.applyInitialTheme);
        window.addEventListener('load', window.themeHelper.applyInitialTheme);
        
        // Instant theme consistency using MutationObserver
        function ensureThemeConsistency() {
            const savedTheme = localStorage.getItem('theme');
            const isDark = savedTheme === 'dark';
            const hasDarkClass = document.documentElement.classList.contains('dark');
            
            if (isDark && !hasDarkClass) {
                document.documentElement.classList.add('dark');
                console.log('Instantly reapplied dark theme');
            } else if (!isDark && hasDarkClass) {
                document.documentElement.classList.remove('dark');
                console.log('Instantly reapplied light theme');
            }
        }
        
        // Use MutationObserver for instant DOM change detection
        const themeObserver = new MutationObserver(function(mutations) {
            let shouldCheck = false;
            
            mutations.forEach(function(mutation) {
                // Check if the documentElement class list changed
                if (mutation.type === 'attributes' && 
                    mutation.attributeName === 'class' && 
                    mutation.target === document.documentElement) {
                    shouldCheck = true;
                }
                // Also check for added/removed nodes that might affect rendering
                else if (mutation.type === 'childList' && 
                         (mutation.addedNodes.length > 0 || mutation.removedNodes.length > 0)) {
                    shouldCheck = true;
                }
            });
            
            if (shouldCheck) {
                // Use requestAnimationFrame to ensure DOM is fully updated
                requestAnimationFrame(ensureThemeConsistency);
            }
        });
        
        // Start observing changes to the entire document
        themeObserver.observe(document.documentElement, {
            attributes: true,
            attributeFilter: ['class'],
            childList: true,
            subtree: true
        });
        
        // Also run consistency check immediately and on key events
        ensureThemeConsistency();
        document.addEventListener('DOMContentLoaded', ensureThemeConsistency);
        window.addEventListener('load', ensureThemeConsistency);
        
        // Scroll to Top Widget Functions
        let scrollToTopComponent = null;
        let scrollToTopListener = null;
        
        window.initializeScrollToTop = function(dotnetHelper) {
            scrollToTopComponent = dotnetHelper;
            
            // Add scroll listener to track scroll position
            scrollToTopListener = function() {
                const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
                const shouldShow = scrollTop > 300; // Show after scrolling 300px
                
                if (scrollToTopComponent) {
                    scrollToTopComponent.invokeMethodAsync('UpdateVisibility', shouldShow);
                }
            };
            
            window.addEventListener('scroll', scrollToTopListener, { passive: true });
            
            // Initial check
            scrollToTopListener();
        };
        
        window.disposeScrollToTop = function() {
            if (scrollToTopListener) {
                window.removeEventListener('scroll', scrollToTopListener);
                scrollToTopListener = null;
            }
            scrollToTopComponent = null;
        };
    </script>
</body>

</html>
