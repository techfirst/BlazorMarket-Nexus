<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <base href="/" />
    <!-- Google Fonts - Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <script>
        // Apply dark theme immediately if saved in localStorage - prevents flash
        (function() {
            try {
                if (localStorage.getItem('theme') === 'dark') {
                    document.documentElement.classList.add('dark');
                }
            } catch (e) {
                // Ignore localStorage errors
            }
        })();
    </script>
    <link rel="stylesheet" href="css/app.css" />
    <link rel="stylesheet" href="Nexus.styles.css" />
    <link rel="icon" type="image/png" href="favicon.png" />
    <HeadOutlet />
</head>

<body>
    <Routes />
    <script src="_framework/blazor.web.js"></script>
    <script>
        // Blazor anchor navigation system
        let isNavigatingToHash = false;
        let retryCount = 0;
        const maxRetries = 10;
        
        // Handle initial hash scroll after page load
        function handleInitialHashScroll() {
            if (window.location.hash && window.location.pathname === '/') {
                const sectionId = window.location.hash.substring(1);
                setTimeout(() => scrollToSection(sectionId), 200);
            }
        }
        
        // Smooth scroll to section function with retry logic
        function scrollToSection(sectionId) {
            const targetSection = document.getElementById(sectionId);
            
            if (targetSection) {
                const headerOffset = 80;
                const elementPosition = targetSection.getBoundingClientRect().top;
                const offsetPosition = elementPosition + window.pageYOffset - headerOffset;
                
                window.scrollTo({
                    top: offsetPosition,
                    behavior: 'smooth'
                });
                
                retryCount = 0; // Reset retry count on success
            } else {
                retryCount++;
                
                // Element not found yet, try again with exponential backoff
                if (retryCount < maxRetries) {
                    const delay = Math.min(200 * retryCount, 2000); // Cap at 2 seconds
                    setTimeout(() => scrollToSection(sectionId), delay);
                } else {
                    retryCount = 0; // Reset for next attempt
                }
            }
        }
        
        // Enhanced hash change handler
        window.addEventListener('hashchange', function(event) {
            const sectionId = window.location.hash.substring(1);
            
            if (sectionId) {
                if (window.location.pathname === '/') {
                    // Already on home page, scroll immediately
                    scrollToSection(sectionId);
                } else {
                    // Not on home page, navigation will occur
                    isNavigatingToHash = true;
                }
            }
        });
        
        // Listen for Blazor navigation events
        window.addEventListener('popstate', function(event) {
            setTimeout(handleInitialHashScroll, 100);
        });
        
        // Blazor-specific: Handle after Blazor renders
        document.addEventListener('DOMContentLoaded', function() {
            handleInitialHashScroll();
        });
        
        // Additional check after potential Blazor re-renders
        function checkPendingHashNavigation() {
            if (isNavigatingToHash && window.location.hash && window.location.pathname === '/') {
                isNavigatingToHash = false;
                const sectionId = window.location.hash.substring(1);
                setTimeout(() => scrollToSection(sectionId), 300);
            }
        }
        
        // Check for pending navigation periodically
        setInterval(checkPendingHashNavigation, 500);
        
        // Theme management for coordination with C# ThemeService
        window.themeHelper = {
            // Apply theme from localStorage on initial load only
            applyInitialTheme: function() {
                try {
                    const savedTheme = localStorage.getItem('theme');
                    if (savedTheme === 'dark') {
                        document.documentElement.classList.add('dark');
                    } else {
                        document.documentElement.classList.remove('dark');
                    }
                } catch (e) {
                    // Ignore localStorage errors
                }
            },
            
            // Called by C# ThemeService to apply theme changes
            setTheme: function(isDark) {
                try {
                    // Force immediate theme application
                    document.documentElement.classList.remove('dark');
                    if (isDark) {
                        document.documentElement.classList.add('dark');
                    }
                    
                    // Also save to localStorage immediately
                    localStorage.setItem('theme', isDark ? 'dark' : 'light');
                } catch (e) {
                    throw e; // Re-throw so C# can catch it
                }
            },
            
            // Get current theme state
            getThemeState: function() {
                return {
                    classList: document.documentElement.className,
                    hasDark: document.documentElement.classList.contains('dark'),
                    localStorage: localStorage.getItem('theme')
                };
            }
        };
        
        // Apply initial theme immediately - before any rendering
        window.themeHelper.applyInitialTheme();
        
        // Apply theme as early as possible to prevent flash
        (function() {
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme === 'dark') {
                document.documentElement.classList.add('dark');
            }
        })();
        
        // Apply initial theme on page load events
        document.addEventListener('DOMContentLoaded', window.themeHelper.applyInitialTheme);
        window.addEventListener('load', window.themeHelper.applyInitialTheme);
        
        // Instant theme consistency using MutationObserver
        function ensureThemeConsistency() {
            const savedTheme = localStorage.getItem('theme');
            const isDark = savedTheme === 'dark';
            const hasDarkClass = document.documentElement.classList.contains('dark');
            
            if (isDark && !hasDarkClass) {
                document.documentElement.classList.add('dark');
            } else if (!isDark && hasDarkClass) {
                document.documentElement.classList.remove('dark');
            }
        }
        
        // Use MutationObserver for instant DOM change detection
        const themeObserver = new MutationObserver(function(mutations) {
            let shouldCheck = false;
            
            mutations.forEach(function(mutation) {
                // Check if the documentElement class list changed
                if (mutation.type === 'attributes' && 
                    mutation.attributeName === 'class' && 
                    mutation.target === document.documentElement) {
                    shouldCheck = true;
                }
                // Also check for added/removed nodes that might affect rendering
                else if (mutation.type === 'childList' && 
                         (mutation.addedNodes.length > 0 || mutation.removedNodes.length > 0)) {
                    shouldCheck = true;
                }
            });
            
            if (shouldCheck) {
                // Use requestAnimationFrame to ensure DOM is fully updated
                requestAnimationFrame(ensureThemeConsistency);
            }
        });
        
        // Start observing changes to the entire document
        themeObserver.observe(document.documentElement, {
            attributes: true,
            attributeFilter: ['class'],
            childList: true,
            subtree: true
        });
        
        // Also run consistency check immediately and on key events
        ensureThemeConsistency();
        document.addEventListener('DOMContentLoaded', ensureThemeConsistency);
        window.addEventListener('load', ensureThemeConsistency);
        
        // Scroll to Top Widget Functions
        let scrollToTopComponent = null;
        let scrollToTopListener = null;
        
        window.initializeScrollToTop = function(dotnetHelper) {
            scrollToTopComponent = dotnetHelper;
            
            // Add scroll listener to track scroll position
            scrollToTopListener = function() {
                const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
                const shouldShow = scrollTop > 300; // Show after scrolling 300px
                
                if (scrollToTopComponent) {
                    scrollToTopComponent.invokeMethodAsync('UpdateVisibility', shouldShow);
                }
            };
            
            window.addEventListener('scroll', scrollToTopListener, { passive: true });
            
            // Initial check
            scrollToTopListener();
        };
        
        window.disposeScrollToTop = function() {
            if (scrollToTopListener) {
                window.removeEventListener('scroll', scrollToTopListener);
                scrollToTopListener = null;
            }
            scrollToTopComponent = null;
        };
    </script>
</body>

</html>
